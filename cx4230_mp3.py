# -*- coding: utf-8 -*-
"""cx4230-mp3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r0Tggq-YFMZ7xWLqSSL3UqROnNz6I_99
"""

import numpy as np
import random
import pandas as pd
from datetime import datetime
from dataclasses import dataclass, field
from typing import Callable

from google.colab import drive

drive.mount('/content/drive')

trip_stats_df = pd.read_csv('/content/drive/MyDrive/trip_stats.csv')
start_station_df = pd.read_csv('/content/drive/MyDrive/start_station_probs.csv')
trip_stats_df

start_station_df

start_station_df = start_station_df.rename(columns={"Unnamed: 0": 'start_station_name', 'start_station_name': 'probability'})
start_station_df

riders = 3500
lam = 2.38
mu = 2.78
sigma = 0.619
stations = 81
initial_bikes = 10
max_bikes = 10

locations_and_probs = []
locations = []
station_count = len(start_station_df)
for i in range(station_count):
  tup = (start_station_df['start_station_name'].loc[start_station_df.index[i]],
         start_station_df['probability'].loc[start_station_df.index[i]])
  locations_and_probs.append(tup)
  locations.append(start_station_df['start_station_name'].loc[start_station_df.index[i]])

locations_and_probs = sorted(locations_and_probs, key=lambda location: location[0])
print(locations_and_probs)
locations = sorted(locations)
print(locations)

start_probabilities = []
for i in range(81):
  start_probabilities.append(locations_and_probs[i][1])
start_probabilities

df = trip_stats_df[trip_stats_df['start'] == locations[0]]
df

new_location_probabilities = []
for i in range(81):
  df = trip_stats_df[trip_stats_df['start'] == locations[i]]
  new_location_probabilities.append(df['count'].to_numpy()/df['count'].to_numpy().sum())
new_location_probabilities

new_location_indices = []
for i in range(81):
  df = trip_stats_df[trip_stats_df['start'] == locations[i]]
  new_location_indices.append(df['end'].to_numpy())
new_location_indices

waiting_for_bike = [0]*81
waiting_to_return = [0]*81
bikes_available = [10]*81
now = datetime.now()
current_time = now.strftime("%H:%M:%S")
current_time

def static_vars(**kwargs):
    def decorate(func):
        for k in kwargs:
            setattr(func, k, kwargs[k])
        return func
    return decorate
@static_vars(t=0)
def now():
    return now.t
print(now())

def set_time(t_new=0):
    now.t = t_new
    return now()
def get_time():
    return now()

"""Events: \\
Arrive to pick up bike \\
Return bike
"""

class FutureEventList:
    def __init__(self):
        self.events = []

    def __iter__(self):
        return self

    def __next__(self) -> Event:
        from heapq import heappop
        if self.events:
            return heappop(self.events)
        raise StopIteration

    def __repr__(self) -> str:
        from pprint import pformat
        return pformat(self.events)

    def len(self) -> int:
      return len(self.events)

class Rider:
  def __init__(self, start_index, arrival_time):
    self.start_index = start_index
    self.arrival_time = arrival_time
    self.end_index = None
    self.bike_rental_time = None
    self.end_time = None
    self.ended = False
    self.return_time = None
    self.rented = False

  def __lt__(self, other):
    return self.arrival_time < other.arrival_time

  def set_end_index(self, index):
    self.end_index = index
  def set_end_time(self, time):
    self.end_time = time
  def set_bike_rental_time(self, time):
    self.bike_rental_time = time

def schedule(e: Event, fev: FutureEventList): # inserts `e` into `fev`
    from heapq import heappush
    heappush(fev.events, e)

@dataclass(order=True)
class Event:
    t: int
    f: Callable=field(compare=False)
    r: Rider

def initialize_events(size, event_list):
  initial_arrival_times = np.random.exponential(scale=1.0/2.38, size=size)
  initial_locations = np.random.choice(81, size=size, p=start_probabilities)
  initial_arrival_times = np.cumsum(initial_arrival_times)
  #print(initial_arrival_times[size-1])
  for i in range(size):
    rider = Rider(initial_locations[i], initial_arrival_times[i])
    riders.append(rider)
    schedule(Event(rider.arrival_time, arrive, rider), event_list)

def initial_state():
    return {'waiting_for_bike': [[]]*81,
            'waiting_to_return': [[]]*81,
            'bikes_available': [max_bikes]*81,
            'bikes_rented': 0,
            'bikes_returned': 0,
            'bikes_lost': 0,
            'max_waitlist_length': [0]*81,
            'bikes_rented_location': [0]*81}

def simulate(state, event_list, verbose=False):
    i = 0
    for e in event_list:

        set_time(e.t)
        #print(get_time())
        if e.t > 1440:
          break

        i = i+1
        e.f(state, e.r, event_list)

def arrive(s, rider, fev):
  if s['bikes_available'][rider.start_index] == 0:
    temp = s['waiting_for_bike'][rider.start_index].copy()
    temp.append(rider)
    s['waiting_for_bike'][rider.start_index] = temp

  if len(s['waiting_for_bike'][rider.start_index]) > s['max_waitlist_length'][rider.start_index]:
    s['max_waitlist_length'][rider.start_index] = len(s['waiting_for_bike'][rider.start_index])

  if s['bikes_available'][rider.start_index] > 0:
    s['bikes_available'][rider.start_index] -= 1

    s['bikes_rented'] += 1
    s['bikes_rented_location'][rider.start_index] += 1
    rider.rented = True
    rider.bike_rental_time = now()
    #get next location and travel time
    travel_time = np.random.lognormal(mean=2.78, sigma=0.619)
    #get a new location, but doesn't necessarily correspond since not all starts go to all ends
    temp_index = np.random.choice(len(new_location_probabilities[rider.start_index]), size=1, p=new_location_probabilities[rider.start_index])
    new_location = new_location_indices[rider.start_index][temp_index]
    if new_location in locations:
      new_index = locations.index(new_location)
      rider.end_index = new_index
      rider.return_time = now() + travel_time
      schedule(Event(now() + travel_time, return_bike, rider), fev)
    else:
      s['bikes_lost'] += 1
  if len(s['waiting_to_return'][rider.start_index]) > 0 and s['bikes_available'][rider.start_index] < max_bikes:

    new_rider = s['waiting_to_return'][rider.start_index].pop(0)
    schedule(Event(now(), return_bike, new_rider), fev)

def return_bike(s, rider, fev):

  if s['bikes_available'][rider.end_index] == max_bikes:
    temp = s['waiting_to_return'][rider.end_index].copy()
    temp.append(rider)
    s['waiting_to_return'][rider.end_index] = temp
  if s['bikes_available'][rider.end_index] < max_bikes:
    rider.ended = True
    rider.end_time = now()
    s['bikes_available'][rider.end_index] += 1
    s['bikes_returned'] += 1
    if len(s['waiting_for_bike'][rider.end_index]) > 0:
      new_rider = s['waiting_for_bike'][rider.end_index].pop(0)
      schedule(Event(now(), arrive, new_rider), fev)

max_bikes = 10
riders = []
event_list = FutureEventList()
state = initial_state()
print(state)
initialize_events(3500, event_list)
#print(state['bikes_rented'])
print(sum(state['bikes_available']))
simulate(state, event_list)
#print(sum(state['waiting_for_bike']))
#print(state['bikes_available'])
#print(state['waiting_to_return'])
#print(state['waiting_for_bike'])
print(state['bikes_available'])
#print(len(state['waiting_to_return']))
print(state['bikes_rented'])
print(state['bikes_returned'])
print(state['bikes_lost'])
print(state['max_waitlist_length'])

"""Testing the model"""

max_bikes = 10
riders = []
event_list = FutureEventList()
state = initial_state()
initialize_events(1, event_list)
rider = riders[0]
print(rider.start_index)
simulate(state, event_list)
print(state['bikes_available'][rider.start_index])
print(state['waiting_to_return'][rider.end_index])
print(rider.rented)
print(rider.ended)

"""As you can see, with just one person renting a bike, they successfully rent a bike, the bike number at that location decreases. When the rider tries to return to a location, it gets added to the waiting to return list because no one else has rented a bike from there yet and we cannot go over max capacity of 10. Additionally, the rider rented variable correctly is True and the rider.ended is false."""

max_bikes = 0
riders = []
event_list = FutureEventList()
state = initial_state()
initialize_events(1, event_list)
rider = riders[0]
print(rider.start_index)
simulate(state, event_list)
print(state['bikes_available'][rider.start_index])
print(state['waiting_for_bike'][rider.start_index])
print(rider.rented)

"""In this test, there are no bikes to begin with, when the first rider arrives at their initial position, they are unable to get a bike so they are added to the waiting for bike queue, and rented is still false"""

max_bikes = 0
event_list = FutureEventList()
state = initial_state()
rider1 = Rider(0, 1)
rider2 = Rider(0, 2)
print(rider1)
print(rider2)
schedule(Event(rider1.arrival_time, arrive, rider1), event_list)
schedule(Event(rider2.arrival_time, arrive, rider2), event_list)
print(event_list)
simulate(state, event_list)
print(state['waiting_for_bike'][rider1.start_index])
state['waiting_for_bike'][rider1.start_index].pop(0)
print(state['waiting_for_bike'][rider1.start_index])

"""If two riders try to pick up a bike when there are none left, the first one to arrive becomes first in line for a bike and pop correctly removes them from the list."""

max_bikes = 0
event_list = FutureEventList()
state = initial_state()

rider1 = Rider(0, 1)
rider2 = Rider(1, 2)
schedule(Event(rider1.arrival_time, arrive, rider1), event_list)
schedule(Event(rider2.arrival_time, arrive, rider2), event_list)
simulate(state, event_list)
print(state['waiting_for_bike'])

"""The waiting for bike array adds the waiting riders to the correct indices."""

max_bikes = 10
riders = []
event_list = FutureEventList()
state = initial_state()
initialize_events(3500, event_list)
print(sum(state['bikes_available']))
simulate(state, event_list)
print("bikes available", sum(state['bikes_available']))
print("bikes rented but not returned yet", state['bikes_rented'] - state['bikes_returned'])

"""We start with 810 bikes, 10 at each station. At the end of the simulation if we add up the bikes which are remaining available at station with the number rented - number returned (because some people are still waiting to return theirs, some are still riding, and a couple went to end destinations which are not in our set of starting locations) and it still equals 810 which is good."""

max_bikes = 10
riders = []
event_list = FutureEventList()
state = initial_state()
rider1 = Rider(0, 1)
rider1.return_time = 1
rider1.end_index = 0
schedule(Event(rider1.return_time, return_bike, rider1), event_list)
simulate(state, event_list)
print(state['bikes_available'][rider1.end_index])
print(state['waiting_to_return'][rider1.end_index])
state = initial_state()
state['bikes_available'][0] = 9
schedule(Event(rider1.return_time, return_bike, rider1), event_list)
print(state['bikes_available'][rider1.end_index])
simulate(state, event_list)
print(state['bikes_available'][rider1.end_index])
print(state['waiting_to_return'][rider1.end_index])

"""This is two tests: the first shows that if we try to return a rider when there are already the maximum bikes, the bikes stays at 10 and the rider gets added to the waitlist to return. The second shows if there is not the max number of bikes, the return is successful and the bike count goes up 1."""

max_bikes = 10
riders = []
event_list = FutureEventList()
state = initial_state()
rider1 = Rider(0, 1)
rider2 = Rider(0, 5)
rider1.return_time = 1
rider1.end_index = 0
schedule(Event(rider1.return_time, return_bike, rider1), event_list)
print(event_list)
simulate(state, event_list)
print(state['bikes_available'][rider1.end_index])
print(state['waiting_to_return'][rider1.end_index])
schedule(Event(rider2.arrival_time, arrive, rider2), event_list)
print(event_list)
simulate(state, event_list)
print(state['bikes_available'][rider1.end_index])
print(state['waiting_to_return'][rider1.end_index])

"""This tests the calling of a return when the number of bikes goes below the maximum. We first have a bike try to return at index 0, it is unable, so the rider is added to the waiting to return queue. Then a rider arrives to pick up a bike, they take a bike successfully, the rider from the return queue is able to return their bike, so the bikes available stays at ten and they are no longer in the queue."""

max_bikes = 10
riders = []
event_list = FutureEventList()
state = initial_state()
state['bikes_available'][0] = 0
rider1 = Rider(0, 5)
rider2 = Rider(0, 1)
rider1.return_time = 5
rider1.end_index = 0
schedule(Event(rider2.arrival_time, arrive, rider2), event_list)
print(event_list)
simulate(state, event_list)
print(state['bikes_available'][0])
print(state['waiting_for_bike'][0])
schedule(Event(rider1.return_time, return_bike, rider1), event_list)
print(event_list)
simulate(state, event_list)
print(state['bikes_available'][0])
print(state['waiting_for_bike'][0])

"""This is very similar to the previous test. This shows that if we have no bikes available and someone arrives, the bikes does not decrement, and the rider is added to the waiting for bike queue. If a rider then returns a bike to that location, the bike count temporarily goes up allowing the first rider to exit the queue and rent the new bike, resetting the bike count to 0."""

max_bikes = 10
riders = []
event_list = FutureEventList()
state = initial_state()
state['bikes_available'][0] = 0
rider1 = Rider(0, 5)
rider2 = Rider(0, 1)
rider1.return_time = 5
rider1.end_index = 0
schedule(Event(rider2.arrival_time, arrive, rider2), event_list)
schedule(Event(rider1.return_time, return_bike, rider1), event_list)
print(event_list)
simulate(state, event_list)
print(rider2.arrival_time, rider2.bike_rental_time)

"""This is the same scenario, but I am using it to show that the arrival time and bike rental time variables are correctly stored in the rider. Their initial arrival is at t=1, the next rider returns at t=5 and therefore the rider should have a bike rental time of 5 which is correct. This rider has a waiting time of 4 minutes.

Through these tests, I have shown that events are scheduled correctly, bikes are not lost during simulation (except when they go to locations which are not in the start location list), the waiting for bike and waiting to return queues work correctly, if there are no bikes then you cannot rent a bike, if there are bikes available then you can rent one, and that my variables for tracking waiting time work correctly. I also show my rented and ended variables work correctly, although they are not used until the next section.
"""

#2.2

trials = 50
probability_of_success = []
average_wait_time = []
for i in range(trials):
  max_bikes = 10
  riders = []
  event_list = FutureEventList()
  state = initial_state()
  initialize_events(3500, event_list)
  simulate(state, event_list)
  success_rate = state['bikes_rented']/3500
  probability_of_success.append(success_rate)
  arrival_times_sum = 0
  rental_times_sum = 0
  for rider in riders:
    if rider.rented == True:
      arrival_times_sum += rider.arrival_time
      rental_times_sum += rider.bike_rental_time
  avg_wait_time = (rental_times_sum - arrival_times_sum)/state['bikes_rented']
  average_wait_time.append(avg_wait_time)

import scipy.stats as st

print(probability_of_success)
print(average_wait_time)
success_mean = np.mean(probability_of_success)
print(success_mean)
wait_mean = np.mean(average_wait_time)
print(wait_mean)
success_stdev = np.std(probability_of_success)
wait_stdev = np.std(average_wait_time)
success_interval = st.t.interval(confidence=0.90, df=len(probability_of_success)-1,
                 loc=success_mean,
                 scale=st.sem(probability_of_success))
wait_interval = st.t.interval(confidence=0.90, df=len(average_wait_time)-1,
                 loc=wait_mean,
                 scale=st.sem(average_wait_time))
print('probability of getting a bike, interval', success_interval)
print('average wait time, interval', wait_interval)

"""**2.3**
The problem statement is a bit vague, so what I will be doing is simulating and determining what the minimum number of bikes at each station which lead to an average wait time of 0 with the condition that there is no maximum bikes at a location, so there is never any waiting to return
"""

max_bikes = 0
riders = []
event_list = FutureEventList()
state = initial_state()
initialize_events(3500, event_list)
max_bikes = 1000000
simulate(state, event_list)
print(state['max_waitlist_length'])
print(state['waiting_for_bike'])
print(state['bikes_rented_location'])

max_bikes = 30
riders = []
event_list = FutureEventList()
state = initial_state()
initialize_events(3500, event_list)
max_bikes = 1000000
simulate(state, event_list)
print(state['max_waitlist_length'])
print(state['waiting_for_bike'])
print(state['bikes_rented_location'])
arrival_times_sum = 0
rental_times_sum = 0
for rider in riders:
  if rider.rented == True:
    arrival_times_sum += rider.arrival_time
    rental_times_sum += rider.bike_rental_time
avg_wait_time = (rental_times_sum - arrival_times_sum)/state['bikes_rented']
print(avg_wait_time)

"""If each location has 30 bikes and no upper bound, there is no wait time"""

max_bikes = 25
riders = []
event_list = FutureEventList()
state = initial_state()
initialize_events(3500, event_list)
max_bikes = 1000000
simulate(state, event_list)
print(state['max_waitlist_length'])
print(state['waiting_for_bike'])
print(state['bikes_rented_location'])
arrival_times_sum = 0
rental_times_sum = 0
for rider in riders:
  if rider.rented == True:
    arrival_times_sum += rider.arrival_time
    rental_times_sum += rider.bike_rental_time
avg_wait_time = (rental_times_sum - arrival_times_sum)/state['bikes_rented']
print(avg_wait_time)

max_bikes = 25
riders = []
event_list = FutureEventList()
state = initial_state()
initialize_events(3500, event_list)
max_bikes = 1000000
simulate(state, event_list)
print(state['max_waitlist_length'])
print(state['waiting_for_bike'])
print(state['bikes_rented_location'])
arrival_times_sum = 0
rental_times_sum = 0
for rider in riders:
  if rider.rented == True:
    arrival_times_sum += rider.arrival_time
    rental_times_sum += rider.bike_rental_time
avg_wait_time = (rental_times_sum - arrival_times_sum)/state['bikes_rented']
print(avg_wait_time)

"""With 25 bikes at each station, we can get a perfect simulation where no one waits, but sometimes we don't"""

max_bikes = 26
wait_time_list = []
for i in range(25):
  riders = []
  event_list = FutureEventList()
  state = initial_state()
  initialize_events(3500, event_list)
  max_bikes = 1000000
  simulate(state, event_list)
  print(state['max_waitlist_length'])
  arrival_times_sum = 0
  rental_times_sum = 0
  for rider in riders:
    if rider.rented == True:
      arrival_times_sum += rider.arrival_time
      rental_times_sum += rider.bike_rental_time
  avg_wait_time = (rental_times_sum - arrival_times_sum)/state['bikes_rented']
  wait_time_list.append(avg_wait_time)
print(sum(wait_time_list))

"""Running the simulation 25 times with 26 bikes at each station to start and no maximum bikes, we get an overall wait time of 0. Therefore, if we initialize each station with 26 bikes, no one will have to wait to get a bike

When running the simulation 10 times with 26 bikes at each starting location and no max capacity, no riders ever have to wait for a bike
"""